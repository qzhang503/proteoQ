% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/proteoQ-peptable.R
\name{normPep}
\alias{normPep}
\title{Reports peptide results}
\usage{
normPep(id = c("pep_seq", "pep_seq_mod"), method_psm_pep = c("median",
  "mean", "weighted.mean", "top.3"), group_pep_by = c("prot_acc",
  "gene"), method_align = c("MC", "MGKernel"), range_log2r = c(10, 90),
  range_int = c(5, 95), n_comp = NULL, seed = NULL,
  annot_kinases = FALSE, col_refit = NULL, cache = TRUE,
  plot_log2FC_cv = TRUE, ...)
}
\arguments{
\item{id}{Depreciated: character string; the variable for summarisation of
\code{PSMs} into peptides. The option \code{id = pep_seq} corresponds to the
summarisation by the primary sequences of peptides. The option \code{id =
pep_seq_mod} corresponds to the summarisation by both the primary sequences
and variable modifications of peptides. \code{PSMs} data with the same value
in \code{pep_seq} or \code{pep_seq_mod} will be summarised into a single
entry of peptide. NB: the value of \code{id} will match automatically to the
value of \code{group_psm_by} in \code{normPSM}.}

\item{method_psm_pep}{Character string; the method to summarise the
\code{log2FC} and the \code{intensity} of \code{PSMs} by peptide entries.
The descriptive statistics includes \code{c("mean", "median", "top.3",
"weighted.mean")}. The \code{log10-intensity} of reporter ions at the
\code{PSMs} levels will be the weight when summarising \code{log2FC} with
\code{"top.3"} or \code{"weighted.mean"}.}

\item{group_pep_by}{Depreciated: a character string for the grouping of
peptide entries. At the \code{prot_acc} default, descriptive statistics will
be calculated based on the same \code{prot_acc} groups. At
\code{group_pep_by = gene}, proteins with the same gene name but different
accession numbers will be treated as one group. NB: the value of
\code{group_pep_by} will match automatically to the value of
\code{group_pep_by} in \code{normPSM}.}

\item{method_align}{Character string or a list of gene symbols; the method to
align the \code{log2FC} of peptide/protein entries across samples.
\code{MC}: median-centering; \code{MGKernel}: the kernal density defined by
multiple Gaussian functions (\code{\link[mixtools]{normalmixEM}}). At
\code{method_align = "MC"}, the ratio profiles of each sample will be
aligned in that the medians of the \code{log2FC} are zero. At
\code{method_align = "MGKernel"}, the \code{log2FC} will be aligned in that
the maximums of kernel density are zero. It is also possible to align the
\code{log2FC} to the median of a list of user-supplied genes:
\code{method_align = c("ACTB", "GAPDH", ...)}.}

\item{range_log2r}{Numeric vector at length two; the range of the
\code{log2FC} of peptide/protein entries for use in the scaling
normalization of standard deviation across samples. The default is between
the 10th and the 90th quantiles.}

\item{range_int}{Numeric vector at length two; the range of the
\code{intensity} of reporter ions for use in the scaling normalization of
standard deviation across samples. The default is between the 5th and the
95th quantiles.}

\item{n_comp}{Integer; the number of Gaussian components to be used with
\code{method_align = "MGKernel"}. A typical value is 2 or 3. The variable
\code{n_comp} overwrites the augument \code{k} in
\code{\link[mixtools]{normalmixEM}}.}

\item{seed}{Integer; a seed for reproducible fitting at \code{method_align =
MGKernel}.}

\item{annot_kinases}{Logical; if TRUE, annotates kinase attributes of
proteins.}

\item{col_refit}{Character string to a column key in \code{expt_smry.xlsx}.
Samples corresponding to non-empty entries under \code{col_refit} will be
used in the refit of \code{log2FC} using multiple Gaussian kernels. The
density estimates from an earlier analyis will be kept for the remaining
samples. At the \code{NULL} default, the column key of \code{Sample_ID} will
be used, which results in the refit of the \code{log2FC} for all samples.}

\item{cache}{Logical; if TRUE, use cache.}

\item{plot_log2FC_cv}{Logical; if TRUE, prepares the violin plots of the CV of
peptide \code{log2FC} for each sample.}

\item{...}{\code{filter_}: Logical expression(s) for the row filtration of
data; also see \code{\link{normPSM}}. \cr Additional parameters for
\code{\link[mixtools]{normalmixEM}}:\cr \code{maxit}, the maximum number of
iterations allowed; \cr \code{epsilon}, tolerance limit for declaring
algorithm convergence.}
}
\value{
The primary output is in \code{~\\dat_dir\\Peptide\\Peptide.txt}.
}
\description{
\code{normPep} summarises
\code{\href{https://www.ebi.ac.uk/pride/help/archive/search/tables}{PSMs}}
into peptides and normalizes the data across
\code{\href{https://en.wikipedia.org/wiki/Tandem_mass_tag}{TMT}} experiments
and \code{LC/MS} injections.
}
\details{
In the primary output file, "\code{Peptide.txt}", values under columns
\code{log2_R...} are logarithmic ratios at base 2 in relative to the
\code{reference(s)} within each multiplex TMT set, or to the row means if no
\code{reference(s)} are present. Values under columns \code{N_log2_R...} are
aligned \code{log2_R...} according to \code{method_align} without scaling
normalization. Values under columns \code{Z_log2_R...} are \code{N_log2_R...}
with additional scaling normalization. Values under columns \code{I...} are
\code{reporter-ion intensity} before normalization. Values under columns
\code{N_I...} are normalized \code{I...}. Values under columns
\code{sd_log2_R...} are the standard deviation of the \code{log2FC} of
proteins from ascribing peptides.

In general, median statistics is applied when summarising numeric values from
PSMs to peptides. One exception is \code{pep_expect} where geometric mean is
used.

Also see \code{\link{normPrn}} for more description of the column keys in the
output.

The peptide counts in individual peptide tables,
\code{TMTset1_LCMSinj1_Peptide_N.txt} et al., may be fewer than the entries
indicated under the \code{prot_n_pep} column after the peptide
removals/cleanups using \code{purgePSM}. Values under columns
\code{N_log2_R...} are intermediate reports by median-centering
\code{log2_R...} without scaling normalization.
}
\examples{
# ===================================
# Prerequisite Fasta and PSM files
# ===================================
library(proteoQDA)
fasta_dir <- "~\\\\proteoQ\\\\dbs\\\\fasta\\\\refseq"
dir.create(fasta_dir, recursive = TRUE, showWarnings = FALSE)
copy_refseq_hs(fasta_dir)
copy_refseq_mm(fasta_dir)

## RUN `Mascot or Maxquant but not both`
dontrun <- TRUE
if (!dontrun) {
  ## Mascot
  dat_dir <- "C:\\\\The\\\\Mascot\\\\Example"
  dir.create(dat_dir, recursive = TRUE, showWarnings = FALSE)
  cptac_csv_1(dat_dir)
  cptac_expt_1(dat_dir)
  cptac_frac_1(dat_dir)
  
	
  ## Maxquant
  #  to install package `proteoQDB` containing MaxQuant examples: 
  #  (1) clone https://github.com/qiangzhang503/proteoQDB.git through `Github Desktop`
  #  (2) local installation of proteoQDB, e.g., devtools::install("~\\\\my_dir\\\\proteoQDB")
  library(proteoQDB)
  dat_dir <- c("C:\\\\The\\\\MQ\\\\Example")
  dir.create(dat_dir, recursive = TRUE, showWarnings = FALSE)
  cptac_mqpsm_txt(dat_dir)
  cptac_mqpsm_expt(dat_dir)
  cptac_mqpsm_frac(dat_dir)	
}
## END of RUN `Mascot or Maxquant but not both`


# ===================================
# Prerequisite PSM normalization
# ===================================
library(proteoQ)

## RUN `Mascot or Maxquant but not both`
dontrun <- TRUE
if (!dontrun) {
  ## Mascot
  dat_dir <- "C:\\\\The\\\\Mascot\\\\Example"
  
	
  ## Maxquant
  dat_dir <- c("C:\\\\The\\\\MQ\\\\Example")
}
## END of RUN `Mascot or Maxquant but not both`

dir.create(dat_dir, recursive = TRUE, showWarnings = FALSE)

load_expts()

normPSM(
  group_psm_by = pep_seq_mod, 
  fasta = c("~\\\\proteoQ\\\\dbs\\\\fasta\\\\refseq\\\\refseq_hs_2013_07.fasta", 
            "~\\\\proteoQ\\\\dbs\\\\fasta\\\\refseq\\\\refseq_mm_2013_07.fasta"), 
)


# ===================================
# Peptide normalization
# ===================================
normPep(
  method_psm_pep = median,
  method_align = MGKernel,
  range_log2r = c(5, 95),
  range_int = c(5, 95),
  n_comp = 3,
  seed = 749662,
  maxit = 200,
  epsilon = 1e-05,
	
  # filter_by_sp = exprs(species == "human"),
)

# renormalization against selected samples
# see README at https://github.com/qzhang503/proteoQ for details about 
#   the selection of sample columns and data rows
normPep(
  method_psm_pep = median, 
  method_align = MGKernel, 
  range_log2r = c(5, 95), 
  range_int = c(5, 95), 
  n_comp = 3, 
  seed = 749662, 
  maxit = 200, 
  epsilon = 1e-05, 
  
  # selected samples
  col_refit = Select_sub,
)

# renormalization based on selected rows
normPep(
  method_psm_pep = median, 
  method_align = MGKernel, 
  range_log2r = c(5, 95), 
  range_int = c(5, 95), 
  n_comp = 3, 
  seed = 749662, 
  maxit = 200, 
  epsilon = 1e-05, 
  
  # selected rows 
  slice_at = exprs(prot_n_psm >= 10, pep_n_psm >= 3), 
)

# renormalization against selected sample columns and data rows
normPep(
  method_psm_pep = median, 
  method_align = MGKernel, 
  range_log2r = c(5, 95), 
  range_int = c(5, 95), 
  n_comp = 3, 
  seed = 749662, 
  maxit = 200, 
  epsilon = 1e-05, 
	
  col_refit = Select_sub,
  slice_at = exprs(prot_n_psm >= 10, pep_n_psm >= 3), 
)

# addtive renormalization against selected sample columns and data rows
# first
normPep(
  method_psm_pep = median, 
  method_align = MGKernel, 
  range_log2r = c(5, 95), 
  range_int = c(5, 95), 
  n_comp = 3, 
  seed = 749662, 
  maxit = 200, 
  epsilon = 1e-05, 
	
  col_refit = W2,
  slice_at = exprs(prot_n_psm >= 5, pep_n_psm >= 3), 
)

# then
normPep(
  method_psm_pep = median, 
  method_align = MGKernel, 
  range_log2r = c(5, 95), 
  range_int = c(5, 95), 
  n_comp = 3, 
  seed = 749662, 
  maxit = 200, 
  epsilon = 1e-05, 
	
  col_refit = W16,
  slice_at = exprs(prot_n_psm >= 8, pep_n_psm >= 4), 
)

# ===================================
# Mixed-bed (1): begin with MGKernel
# ===================================
# (1-1) aligned by `MGKernel`
normPep(
  method_psm_pep = median, 
  method_align = MGKernel, 
  range_log2r = c(20, 95), 
  range_int = c(5, 95), 
  n_comp = 3, 
  seed = 883, 
  maxit = 200, 
  epsilon = 1e-05, 
  filter_peps_by = exprs(pep_len <= 50),
)

pepHist(scale_log2r = TRUE)
pepHist(scale_log2r = FALSE)

# (1-1) followed by median centering for samples specified by `col_refit`
normPep(
  range_log2r = c(5, 95),
  range_int = c(5, 95),  
  
  n_comp = 3,
  seed = 749662,
  maxit = 200,
  epsilon = 1e-05,
  col_refit = Select_sub, 

  filter_peps_by = exprs(pep_len <= 50),
)

# `MGKernel_params_N.txt` available for side-effects
pepHist(scale_log2r = TRUE, filename = "sel_mc_z.png",)
pepHist(scale_log2r = FALSE, filename = "sel_mc_n.png",)

# (1-3) aligned by median-centering for all samples
normPep()

# `MGKernel_params_N.txt` available for side-effects
pepHist(scale_log2r = TRUE, filename = "mc_z.png",)
pepHist(scale_log2r = FALSE, filename = "mc_n.png",)

# (1-4) followed by `MGKernel` for samples specified by `col_refit`
normPep(
  method_psm_pep = median, 
  method_align = MGKernel, 
  range_log2r = c(20, 95), 
  range_int = c(5, 95), 
  n_comp = 3, 
  seed = 883, 
  maxit = 200, 
  epsilon = 1e-05, 
  col_refit = Select_sub, 
  filter_peps_by = exprs(pep_len <= 50),
)

# updated `MGKernel_params_N.txt` for selected samples
pepHist(scale_log2r = TRUE, filename = "sel_mG_z.png",)
pepHist(scale_log2r = FALSE, filename = "sel_mG_n.png",)

# (1-5) fresh start with a different `n_comp = 2`
# will overrule `col_refit` to all samples
normPep(
  method_psm_pep = median, 
  method_align = MGKernel, 
  range_log2r = c(20, 95), 
  range_int = c(5, 95), 
  n_comp = 2, 
  seed = 883, 
  maxit = 200, 
  epsilon = 1e-05, 
  col_refit = Select_sub, 
  filter_peps_by = exprs(pep_len <= 50),
)

# updated `MGKernel_params_N.txt` for all samples
pepHist(scale_log2r = TRUE, filename = "all_mG2_z.png",)
pepHist(scale_log2r = FALSE, filename = "all_mG2_n.png",)


# ===================================
# Mixed-bed (2): begin with MC
# ===================================
unlink(file.path(dat_dir, "Peptide\\\\Histogram"), recursive  = TRUE)
unlink(file.path(dat_dir, "Peptide\\\\Peptide.txt"))

# (2-1) median centering
normPep()

# `MGKernel_params_N.txt` not yet available
pepHist(scale_log2r = TRUE, filename = "mc_z.png",)
pepHist(scale_log2r = FALSE, filename = "mc_n.png",)

# (2-2) this is the first `MGKernel`: 
#   `MGKernel_params_N.txt` not yet available
#   so will overrule `col_refit` to all samples
normPep(
  method_psm_pep = median, 
  method_align = MGKernel, 
  range_log2r = c(20, 95), 
  range_int = c(5, 95), 
  n_comp = 3, 
  seed = 883, 
  maxit = 200, 
  epsilon = 1e-05, 
  col_refit = Select_sub, 
  filter_peps_by = exprs(pep_len <= 50),
)

# `MGKernel_params_N.txt` available
pepHist(scale_log2r = TRUE, filename = "all_mG_z.png",)
pepHist(scale_log2r = FALSE, filename = "all_mG_n.png",)




# ===================================
# Mixed-bed (3): begin with MC
# ===================================
# following Mixed-bed (2) examples
# normalized against housekeeping proteins for selected samples
normPep(
  range_log2r = c(20, 95), 
  range_int = c(5, 95), 
  col_refit = Select_sub,
  slice_hskp = exprs(gene \%in\% c("ACTB", "GAPDH")),
)

# `MGKernel_params_N.txt` available for side effects
pepHist(scale_log2r = TRUE, filename = "sel_hskp_z.png",)
pepHist(scale_log2r = FALSE, filename = "sel_hskp_n.png",)
# ===================================
# Peptide cleanup by CV
# ===================================
# by percent CV
purgePep(pt_cv = .95)

# by max CV
purgePep(max_cv = .5)

# by `max_cv` then by `pt_cv`
purgePep(max_cv = .5)
purgePep(pt_cv = .95)

# actually 90\% CV 
purgePep(pt_cv = .95)
purgePep(pt_cv = .95)
}
\seealso{
\code{\link{normPSM}} for PSM data normalization and
 \code{\link{normPrn}} for protein data normalization.
}
