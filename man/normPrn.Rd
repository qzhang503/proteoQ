% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/proteoQ-prntable.R
\name{normPrn}
\alias{normPrn}
\title{Reports Protein Results}
\usage{
normPrn(id = c("prot_acc", "gene"), method_pep_prn = c("median",
  "mean", "weighted.mean", "top.3"), use_unique_pep = TRUE,
  method_align = c("MC", "MGKernel"), range_log2r = c(10, 90),
  range_int = c(5, 95), n_comp = NULL, seed = NULL,
  col_refit = NULL, cache = TRUE, ...)
}
\arguments{
\item{id}{Depreciated: character string; the variable to summarise peptides
into proteins. The option \code{prot_acc} corresponds to the summarisation
by the accession numbers or entry names of proteins. The option \code{gene}
corresponds to the summarisation by the gene names of proteins. At \code{id
= gene}, data under the same gene name but different acccesssion numbers or
entry names will be summarised into one entry. NB: the value of \code{id}
will match automatically to the value of \code{group_pep_by} in
\code{normPSM}.}

\item{method_pep_prn}{Character string; the method to summarise the
\code{log2FC} and the \code{intensity} of peptides by protein entries. The
descriptive statistics includes \code{c("mean", "median", "top.3",
"weighted.mean")}. The representative \code{log10-intensity} of reporter
ions at the peptide levels (from \code{\link{normPep}}) will be the weigth
when summarising \code{log2FC} with \code{top.3} or \code{weighted.mean}.}

\item{use_unique_pep}{Logical; if TRUE, only entries that are \code{TRUE} or
equal to \code{1} under the column \code{pep_isunique} in \code{Peptide.txt}
will be used, for summarising the \code{log2FC} and the \code{intensity} of
peptides into protein values. The default is to use unique peptides only.
For \code{MaxQuant} data, the levels of uniqueness are according to the
\code{pep_unique_by} in \code{\link{normPSM}}. The argument currently do
nothing to \code{Spectrum Mill} data where both unique and shared peptides
will be kept.}

\item{method_align}{Character string or a list of gene symbols; the method to
align the \code{log2FC} of peptide/protein entries across samples.
\code{MC}: median-centering; \code{MGKernel}: the kernal density defined by
multiple Gaussian functions (\code{\link[mixtools]{normalmixEM}}). At
\code{method_align = "MC"}, the ratio profiles of each sample will be
aligned in that the medians of the \code{log2FC} are zero. At
\code{method_align = "MGKernel"}, the \code{log2FC} will be aligned in that
the maximums of kernel density are zero. It is also possible to align the
\code{log2FC} to the median of a list of user-supplied genes:
\code{method_align = c("ACTB", "GAPDH", ...)}.}

\item{range_log2r}{Numeric vector at length two; the range of the
\code{log2FC} of peptide/protein entries for use in the scaling
normalization of standard deviation across samples. The default is between
the 10th and the 90th quantiles.}

\item{range_int}{Numeric vector at length two; the range of the
\code{intensity} of reporter ions for use in the scaling normalization of
standard deviation across samples. The default is between the 5th and the
95th quantiles.}

\item{n_comp}{Integer; the number of Gaussian components to be used with
\code{method_align = "MGKernel"}. A typical value is 2 or 3. The variable
\code{n_comp} overwrites the augument \code{k} in
\code{\link[mixtools]{normalmixEM}}.}

\item{seed}{Integer; a seed for reproducible fitting at \code{method_align =
MGKernel}.}

\item{col_refit}{Character string to a column key in \code{expt_smry.xlsx}.
Samples corresponding to non-empty entries under \code{col_refit} will be
used in the refit of \code{log2FC} using multiple Gaussian kernels. The
density estimates from an earlier analyis will be kept for the remaining
samples. At the \code{NULL} default, the column key of \code{Sample_ID} will
be used, which results in the refit of the \code{log2FC} for all samples.}

\item{cache}{Logical; if TRUE, use cache.}

\item{...}{\code{filter_}: Logical expression(s) for the row filtration of
data; also see \code{\link{normPSM}}. \cr Additional parameters for
\code{\link[mixtools]{normalmixEM}}:\cr \code{maxit}, the maximum number of
iterations allowed; \cr \code{epsilon}, tolerance limit for declaring
algorithm convergence.}
}
\value{
The primary output is in "\code{~\\dat_dir\\Protein\\Protein.txt}".
}
\description{
\code{normPrn} summarises peptides into proteins and performs data
normalization.
}
\details{
For the analysis of Mascot results, the column keys are defined in
\code{\href{http://www.matrixscience.com/help/csv_headers.html}{Matrix
Science}} with the following additions:

\tabular{ll}{ \strong{Header}   \tab \strong{Descrption}\cr length \tab The
number of amino acid residues for a proposed protein \cr acc_type \tab The
type of accession names \cr entrez \tab
\code{\href{https://www.ncbi.nlm.nih.gov/gene}{Protein Entrez ID}} \cr species
\tab The species of a protein entry \cr gene \tab Protein gene name \cr
kin_attr       \tab Optional; the attribute of proteins being kinases \cr
kin_class      \tab Optional; the classes of kinases, e.g., TK, TKL... \cr
kin_order      \tab Optional; the order of "kin_class" from the
\code{\href{http://kinase.com/human/kinome/}{kinase tree diagram}} \cr
prot_n_pep \tab The number of significant peptide sequences matched to a
proposed protein. \cr prot_n_psm \tab The number of significant MS/MS queries
matched to a proposed protein. \cr pep_n_psm \tab The number of significant
MS/MS queries matched to a proposed peptide sequence. \cr pep_seq_mod    \tab
One-letter representation of peptide sequences: amino acid residue(s) with
variable modifications are in the lower cases; the acetylations of protein
N-terminals indicated by '_' and the flanking residues on the N- or C-terminal
side of peptides separated by '.', e.g. "-._mAsGVAVSDGVIK.V"\cr prot_cover
\tab Protein sequence coverage calculated from all available raw files   \cr
raw_file \tab MS file name(s) where peptides or proteins were identified \cr
refseq_acc \tab \code{\href{https://www.ncbi.nlm.nih.gov/refseq/}{Protein
RefSeq accession number}} \cr uniprot_acc    \tab
\code{\href{https://www.uniprot.org/help/accession_numbers}{Protein UniProt
accession number}} \cr uniprot_id     \tab
\code{\href{https://www.uniprot.org/help/entry_name}{Protein UniProt entry
name}} \cr I... (...)     \tab Reporter-ion intensity calculated from the
descriptive statistics in \code{mothod_psm_pep} or \code{mothod_pep_prn} for
indicated samples \cr N_I... (...)   \tab Normalized \code{I... (...)}. The
calibration factors for the alignment of \code{log2FC} are used to scale the
reporter-ion intensity \cr log2_R (...)   \tab \code{log2FC} relative to
reference materials for indicated samples \cr N_log2_R (...) \tab Aligned
\code{log2_R (...)} according to \code{method_align} without scaling
normalization \cr Z_log2_R (...) \tab \code{N_log2_R (...)} with scaling
normalization \cr }

NB: PSM entries with no quantitative contributions are excluded from the
calculations of \code{prot_n_pep}, \code{prot_n_psm} and \code{pep_n_psm}.
}
\examples{
# ===================================
# Fasta and PSM files
# ===================================
library(proteoQDA)
fasta_dir <- "~\\\\proteoQ\\\\dbs\\\\fasta\\\\refseq"
dir.create(fasta_dir, recursive = TRUE, showWarnings = FALSE)
copy_refseq_hs(fasta_dir)
copy_refseq_mm(fasta_dir)

## RUN `Mascot or Maxquant but not both`
dontrun <- TRUE
if (!dontrun) {
  # Mascot
  dat_dir <- "C:\\\\The\\\\Mascot\\\\Example"
  dir.create(dat_dir, recursive = TRUE, showWarnings = FALSE)
  cptac_csv_1(dat_dir)
  cptac_expt_1(dat_dir)
  cptac_frac_1(dat_dir)
  
  # Maxquant
  #   to install package `proteoQDB` containing MaxQuant examples: 
  #    (1) clone https://github.com/qiangzhang503/proteoQDB.git through `Github Desktop`
  #    (2) local installation of proteoQDB, e.g., devtools::install("~\\\\my_dir\\\\proteoQDB")
  library(proteoQDB)
  dat_dir <- c("C:\\\\The\\\\MQ\\\\Example")
  dir.create(dat_dir, recursive = TRUE, showWarnings = FALSE)
  cptac_mqpsm_txt(dat_dir)
  cptac_mqpsm_expt(dat_dir)
  cptac_mqpsm_frac(dat_dir)	
}
## END of RUN `Mascot or Maxquant but not both`


# ===================================
# PSM
# ===================================
library(proteoQ)

## RUN `Mascot or Maxquant but not both`
dontrun <- TRUE
if (!dontrun) {
  # Mascot
  dat_dir <- "C:\\\\The\\\\Mascot\\\\Example"
  dir.create(dat_dir, recursive = TRUE, showWarnings = FALSE)
  load_expts()
	
  normPSM(
    group_psm_by = pep_seq_mod,
    group_pep_by = prot_acc,
    fasta = c("~\\\\proteoQ\\\\dbs\\\\fasta\\\\refseq\\\\refseq_hs_2013_07.fasta",
              "~\\\\proteoQ\\\\dbs\\\\fasta\\\\refseq\\\\refseq_mm_2013_07.fasta"),
    rptr_intco = 3000,
    rm_craps = TRUE,
    rm_krts = FALSE,
    rm_outliers = FALSE,
    annot_kinases = TRUE,
    plot_rptr_int = TRUE,
    plot_log2FC_cv = TRUE,
    
    filter_peps = exprs(pep_expect <= .1),
    filter_by_more = exprs(pep_rank == 1, pep_exp_z > 1),
  )

  # MaxQuant
  dat_dir <- c("C:\\\\The\\\\MQ\\\\Example")
  dir.create(dat_dir, recursive = TRUE, showWarnings = FALSE)
  load_expts()
	
  normPSM(
    group_psm_by = pep_seq_mod,
    group_pep_by = prot_acc,
    fasta = c("~\\\\proteoQ\\\\dbs\\\\fasta\\\\refseq\\\\refseq_hs_2013_07.fasta",
              "~\\\\proteoQ\\\\dbs\\\\fasta\\\\refseq\\\\refseq_mm_2013_07.fasta"),
    corrected_int = TRUE,
    rm_reverses = TRUE,
    rptr_intco = 3000,
    rm_craps = TRUE,
    rm_krts = FALSE,
    rm_outliers = FALSE,
    annot_kinases = TRUE,
    plot_rptr_int = TRUE,
    plot_log2FC_cv = TRUE,
    
    filter_peps = exprs(PEP <= 0.1),
  )
}
## END of RUN `Mascot or Maxquant but not both`



# ===================================
# Peptide
# ===================================
normPep(
  method_psm_pep = median,
  method_align = MGKernel,
  range_log2r = c(5, 95),
  range_int = c(5, 95),
  n_comp = 3,
  seed = 749662,
  maxit = 200,
  epsilon = 1e-05,
  # filter_by_sp = exprs(species == "human"),
)


# ===================================
# Protein
# ===================================
normPrn(
  method_pep_prn = median,
  method_align = MGKernel,
  range_log2r = c(20, 95),
  range_int = c(5, 95),
  n_comp = 2,
  seed = 749662,
  maxit = 200,
  epsilon = 1e-05,
  filter_by = exprs(prot_n_pep >=2, pep_isunique),
)

# renormalization against selected samples
normPrn(
  method_pep_prn = median,
  method_align = MGKernel,
  range_log2r = c(20, 95),
  range_int = c(5, 95),
  n_comp = 2,
  seed = 749662,
  maxit = 200,
  epsilon = 1e-05,
  filter_by = exprs(prot_n_pep >=2, pep_isunique),
  
  # selected samples
  col_refit = Select_sub,	
)

# renormalization against selected samples
normPrn(
  method_pep_prn = median,
  method_align = MGKernel,
  range_log2r = c(20, 95),
  range_int = c(5, 95),
  n_comp = 2,
  seed = 749662,
  maxit = 200,
  epsilon = 1e-05,
  filter_by = exprs(prot_n_pep >=2, pep_isunique),
  
  # selected rows 
  slice_at = exprs(prot_n_psm >= 10), 
)

# renormalization against selected samples using partial data
normPrn(
  method_pep_prn = median,
  method_align = MGKernel,
  range_log2r = c(20, 95),
  range_int = c(5, 95),
  n_comp = 2,
  seed = 749662,
  maxit = 200,
  epsilon = 1e-05,
  filter_by = exprs(prot_n_pep >=2, pep_isunique),
  slice_at = exprs(prot_n_psm >= 10), 
  col_refit = Select_sub,
)








}
\seealso{
\code{\link{normPSM}} for PSMs and \code{\link{normPep}} for
 peptides.
}
\concept{aggregate functions}
